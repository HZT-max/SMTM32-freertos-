#创作日记（回顾版）

1.初始化问题！
特别烦人但是解决方法比较简单，不过当时还是困扰了我很久
（因为部分模块比如OLED和MPU,需要上电后等待一会“开机”，但是我的标准库移植移植的时候需要关掉原先的daley中断
（也许有其他办法，但是那是没有深究，现在才仔细研究中断））又因为在任务调度器之前不允许用xtaskdaley
```c
xTaskCreate(init, "menu", 512, NULL, 3, &xinitTaskHandle);
 vTaskStartScheduler();
```
然后再init里面初始化。


2.小车翻页问题！！！
由于OLED的显示分为页（0-7）与列（0-127），障碍物随列下落，小车需要跨页移动。
最终用两页拼在一起实现显示，并且用位运算实现。
逻辑有点难，但是还好，摸得着看得见，不像初始化等看不见的错误。
```c
void car1_task(void *pvParameters)
{
//    Oledgame m;
    u8 w=0;
	  u8 j,i;
    vTaskDelay(pdMS_TO_TICKS(100)); // 启动延迟
  	w=ENCODER_READ();   //1是右转，2是左转，3是按下
	  for(j=0;j<16;j++){ 
		up1[j]  = car_16x16[j];
    low1[j] = car_16x16[16+j];
		}
	  while(1){
			if (game_over) break;
		  w=ENCODER_READ();
      if (w==1 && car1.turn!=0) {  //右转
				for(i=0;i<16;i++){      
        out1_up[i] = (u8)( ( ( (unsigned int) up1[i] >> 1 ) ) | ( (unsigned int)low1[i] << 7) );
				out1_low[i] = (u8)( (unsigned int)low1[i]>>1 );
				up1[i]  = out1_up[i];
				low1[i] = out1_low[i];
			  }
				enqueue_draw(OLED_CLEAR_car,car1.page, car1.y,car1.data,NULL);
			  enqueue_draw(OLED_DRAW_car ,car1.page, car1.y, out1_up,NULL);
			  enqueue_draw(OLED_DRAW_car ,car1.page+1, car1.y, out1_low,NULL);
			  car1.turn--;
				w = 0;
          }
		   if (w==2 && car1.turn!=10) {     //左转
				 for(i=0;i<16;i++){
				  out1_up[i] = (u8)( (unsigned int)up1[i]<<1 );
          out1_low[i] = (u8)( ( ( (unsigned int)low1[i] << 1 ) ) | ( (unsigned int)up1[i] >> 7) );
					up1[i]  = out1_up[i];
				  low1[i] = out1_low[i];
				 }
				  enqueue_draw(OLED_CLEAR_car,car1.page, car1.y,car1.data,NULL);
			    enqueue_draw(OLED_DRAW_car ,car1.page, car1.y, out1_up,NULL);
			  	enqueue_draw(OLED_DRAW_car ,car1.page+1, car1.y, out1_low,NULL);
			    car1.turn++;
				  w = 0;
          }
			 if(car1.turn==0 && w==1){     //右转到另一页
					car1.turn=7;
				  for(j=0;j<16;j++){ 
			 		up1[j]  = (u8)( (unsigned int)car_16x16[j]<<2 );
          low1[j] = (u8)( ( ( (unsigned int)car_16x16[j+16] << 2 ) ) | ( (unsigned int)car_16x16[j] >> 6) );
					}
				enqueue_draw(OLED_CLEAR_car,car1.page, car1.y,car1.data,NULL);
				car1.page--;
			  enqueue_draw(OLED_DRAW_car ,car1.page, car1.y, up1,NULL);
			  enqueue_draw(OLED_DRAW_car ,car1.page+1, car1.y, low1,NULL);			
		    }
		  if(car1.turn==10 && w==2){     //左转到另一页
			    car1.turn=3;
					for(j=0;j<16;j++){ 
            up1[j]  = (u8)( ( ( (unsigned int) car_16x16[j] >> 2 ) ) | ( (unsigned int)car_16x16[16+j] << 6) );
				    low1[j] = (u8)( (unsigned int)car_16x16[16+j]>>2 );
	      	}
        enqueue_draw(OLED_CLEAR_car,car1.page, car1.y,car1.data,NULL);
				car1.page++;
			  enqueue_draw(OLED_DRAW_car ,car1.page, car1.y, up1,NULL);
			  enqueue_draw(OLED_DRAW_car ,car1.page+1, car1.y, low1,NULL);					
		    }
			vTaskDelay(pdMS_TO_TICKS(10));
		}
		vTaskDelete(NULL);
}
```

3.iic冲突问题！
创建队列统一调度IIC控制，简单。
```c
void oled_game(void *pvParameters)
{
	  TickType_t now,start,wait,eletime,wait2,start2;
    u8 data_page,data_y;
	  u8 *data_data;
	  u16 data_light;
	  u8 data_add,data_bdd;
	  u16 data_num;
	  u8 *data_where;
	  u8 w_time;
    TickType_t timeout = pdMS_TO_TICKS(10000); // 超时时间 3000ms
	  TickType_t timeout2 = pdMS_TO_TICKS(10000); // 超时时间 3000ms
    Oledgame oledgame;
	  readiic iic;
	  QueueSetMemberHandle_t xQueueHandle = NULL;
    start = xTaskGetTickCount();
    while(1){           // 等待队列消息（无限阻塞，直到有显示请求）
			now = xTaskGetTickCount();
			if ((now - start) >= timeout) {
         wait = 0;}
			else {
            wait = timeout - (now - start);}
			xQueueHandle = xQueueSelectFromSet(g_xQueueSetInput, wait);
       if(xQueueHandle){	
        if (xQueueHandle == g_xQueueOLEDform) {
					  xQueueReceive(g_xQueueOLEDform, &oledgame, portMAX_DELAY);
            data_page = oledgame.page;
            data_y = oledgame.y;
					  data_data = oledgame.data;
					  data_num = oledgame.num;
					  start = xTaskGetTickCount();
            switch (oledgame.type){
                case OLED_CLEAR:
                    OLED_DISPLAY_CLEAR();
                    break;
```

4.MPU6050控制问题！！！
涉及解算与判断问题！
更难的是现在都不知道为什么--在有freertos的工程里mpu的识别更灵敏，
读取的数变化更大，相同的解算在裸机上输出的数值更小。（现在才回头深究）
```c
		if(mpu_yes3){
			enqueue_draw(OLED_CLEAR, NULL, NULL, NULL,NULL);
			vTaskDelay(100); 
			OLED_DISPLAY_8x16(6,15*8,mpu_yes3+0x30); 
			while(1){
				vTaskDelay(100);  
				mpu_yes3 = mpu6050_picth();
				OLED_DISPLAY_8x16(6,15*8,mpu_yes3+0x30); 
				if(mpu_yes3 == 0) {break;}
			}
			break;
		}
```
5.各个任务之间的竞争问题！！！！！
即使有队列操控iic，可是任务在某些时候必须要加上一个vtaskdaley函数，没有就不行。
特别是mpu方面的，不知道为什么。（也是现在再回头深究）
```c
		if(turn2 == 3)//确认
		{
			menu3_ok = flag2;
			prev_flag2 = 0;
			vTaskDelay(50);  //不知道为什么，不加这个延迟就回不去（按下等几个瞬间才可以）
		}
  		if(mpu_yes){  //一：不归位就执行；二：误识别
			vTaskDelay(50);   //又是这样，（不归位）加个延时就好了
			enqueue_draw(OLED_8x16,6,15*8,NULL,mpu_yes+0x30);  //啊？（误识别）把这个取消也不行，难道是不观测就
			vTaskDelay(50);
			while(1){
    //在这再加延时就好了。。。666
				mpu_yes = mpu6050_picth();
				enqueue_draw(OLED_8x16,6,15*8,NULL,mpu_yes+0x30); //（误识别）而且这个不能注释掉，我没招了
				vTaskDelay(100);
        if(mpu_yes == 0) {break;}
			}
			turn = 0;
			return flag;
		}
```
